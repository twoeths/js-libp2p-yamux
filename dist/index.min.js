(function (root, factory) {(typeof module === 'object' && module.exports) ? module.exports = factory() : root.ChainsafeLibp2PYamux = factory()}(typeof self !== 'undefined' ? self : this, function () {
"use strict";var ChainsafeLibp2PYamux=(()=>{var z=Object.defineProperty;var xt=Object.getOwnPropertyDescriptor;var At=Object.getOwnPropertyNames;var Dt=Object.prototype.hasOwnProperty;var vt=(s,t)=>{for(var e in t)z(s,e,{get:t[e],enumerable:!0})},Lt=(s,t,e,r)=>{if(t&&typeof t=="object"||typeof t=="function")for(let n of At(t))!Dt.call(s,n)&&n!==e&&z(s,n,{get:()=>t[n],enumerable:!(r=xt(t,n))||r.enumerable});return s};var Ct=s=>Lt(z({},"__esModule",{value:!0}),s);var Xt={};vt(Xt,{GoAwayCode:()=>g,yamux:()=>Bt});var o=class extends Error{code;props;constructor(t,e,r){super(t),this.code=e,this.name=r?.name??"CodeError",this.props=r??{}}};var Y=(s,...t)=>{try{[...t]}catch{}};var nt=Symbol.for("@libp2p/service-capabilities"),Kt=Symbol.for("@libp2p/service-dependencies");function U(s){if(s!=null){if(typeof s[Symbol.iterator]=="function")return s[Symbol.iterator]();if(typeof s[Symbol.asyncIterator]=="function")return s[Symbol.asyncIterator]();if(typeof s.next=="function")return s}throw new Error("argument is not an iterator or iterable")}function y(){let s={};return s.promise=new Promise((t,e)=>{s.resolve=t,s.reject=e}),s}var W=class{buffer;mask;top;btm;next;constructor(t){if(!(t>0)||t-1&t)throw new Error("Max size for a FixedFIFO should be a power of two");this.buffer=new Array(t),this.mask=t-1,this.top=0,this.btm=0,this.next=null}push(t){return this.buffer[this.top]!==void 0?!1:(this.buffer[this.top]=t,this.top=this.top+1&this.mask,!0)}shift(){let t=this.buffer[this.btm];if(t!==void 0)return this.buffer[this.btm]=void 0,this.btm=this.btm+1&this.mask,t}isEmpty(){return this.buffer[this.btm]===void 0}},D=class{size;hwm;head;tail;constructor(t={}){this.hwm=t.splitLimit??16,this.head=new W(this.hwm),this.tail=this.head,this.size=0}calculateSize(t){return t?.byteLength!=null?t.byteLength:1}push(t){if(t?.value!=null&&(this.size+=this.calculateSize(t.value)),!this.head.push(t)){let e=this.head;this.head=e.next=new W(2*this.head.buffer.length),this.head.push(t)}}shift(){let t=this.tail.shift();if(t===void 0&&this.tail.next!=null){let e=this.tail.next;this.tail.next=null,this.tail=e,t=this.tail.shift()}return t?.value!=null&&(this.size-=this.calculateSize(t.value)),t}isEmpty(){return this.head.isEmpty()}};var H=class extends Error{type;code;constructor(t,e){super(t??"The operation was aborted"),this.type="aborted",this.code=e??"ABORT_ERR"}};function M(s={}){return Tt(e=>{let r=e.shift();if(r==null)return{done:!0};if(r.error!=null)throw r.error;return{done:r.done===!0,value:r.value}},s)}function Tt(s,t){t=t??{};let e=t.onEnd,r=new D,n,i,a,h=y(),l=async()=>{try{return r.isEmpty()?a?{done:!0}:await new Promise((u,I)=>{i=O=>{i=null,r.push(O);try{u(s(r))}catch(A){I(A)}return n}}):s(r)}finally{r.isEmpty()&&queueMicrotask(()=>{h.resolve(),h=y()})}},m=u=>i!=null?i(u):(r.push(u),n),p=u=>(r=new D,i!=null?i({error:u}):(r.push({error:u}),n)),d=u=>{if(a)return n;if(t?.objectMode!==!0&&u?.byteLength==null)throw new Error("objectMode was not true but tried to push non-Uint8Array value");return m({done:!1,value:u})},b=u=>a?n:(a=!0,u!=null?p(u):m({done:!0})),N=()=>(r=new D,b(),{done:!0}),_t=u=>(b(u),{done:!0});if(n={[Symbol.asyncIterator](){return this},next:l,return:N,throw:_t,push:d,end:b,get readableLength(){return r.size},onEmpty:async u=>{let I=u?.signal;if(I?.throwIfAborted(),r.isEmpty())return;let O,A;I!=null&&(O=new Promise((zt,It)=>{A=()=>{It(new H)},I.addEventListener("abort",A)}));try{await Promise.race([h.promise,O])}finally{A!=null&&I!=null&&I?.removeEventListener("abort",A)}}},e==null)return n;let x=n;return n={[Symbol.asyncIterator](){return this},next(){return x.next()},throw(u){return x.throw(u),e!=null&&(e(u),e=void 0),{done:!0}},return(){return x.return(),e!=null&&(e(),e=void 0),{done:!0}},push:d,end(u){return x.end(u),e!=null&&(e(u),e=void 0),n},get readableLength(){return x.readableLength},onEmpty:u=>x.onEmpty(u)},n}function E(s=0){return new Uint8Array(s)}function L(s=0){return new Uint8Array(s)}function q(s,t){t==null&&(t=s.reduce((n,i)=>n+i.length,0));let e=L(t),r=0;for(let n of s)e.set(n,r),r+=n.length;return e}function it(s,t){if(s===t)return!0;if(s.byteLength!==t.byteLength)return!1;for(let e=0;e<s.byteLength;e++)if(s[e]!==t[e])return!1;return!0}var at=Symbol.for("@achingbrain/uint8arraylist");function ot(s,t){if(t==null||t<0)throw new RangeError("index is out of bounds");let e=0;for(let r of s){let n=e+r.byteLength;if(t<n)return{buf:r,index:t-e};e=n}throw new RangeError("index is out of bounds")}function k(s){return!!s?.[at]}var S=class s{bufs;length;[at]=!0;constructor(...t){this.bufs=[],this.length=0,t.length>0&&this.appendAll(t)}*[Symbol.iterator](){yield*this.bufs}get byteLength(){return this.length}append(...t){this.appendAll(t)}appendAll(t){let e=0;for(let r of t)if(r instanceof Uint8Array)e+=r.byteLength,this.bufs.push(r);else if(k(r))e+=r.byteLength,this.bufs.push(...r.bufs);else throw new Error("Could not append value, must be an Uint8Array or a Uint8ArrayList");this.length+=e}prepend(...t){this.prependAll(t)}prependAll(t){let e=0;for(let r of t.reverse())if(r instanceof Uint8Array)e+=r.byteLength,this.bufs.unshift(r);else if(k(r))e+=r.byteLength,this.bufs.unshift(...r.bufs);else throw new Error("Could not prepend value, must be an Uint8Array or a Uint8ArrayList");this.length+=e}get(t){let e=ot(this.bufs,t);return e.buf[e.index]}set(t,e){let r=ot(this.bufs,t);r.buf[r.index]=e}write(t,e=0){if(t instanceof Uint8Array)for(let r=0;r<t.length;r++)this.set(e+r,t[r]);else if(k(t))for(let r=0;r<t.length;r++)this.set(e+r,t.get(r));else throw new Error("Could not write value, must be an Uint8Array or a Uint8ArrayList")}consume(t){if(t=Math.trunc(t),!(Number.isNaN(t)||t<=0)){if(t===this.byteLength){this.bufs=[],this.length=0;return}for(;this.bufs.length>0;)if(t>=this.bufs[0].byteLength)t-=this.bufs[0].byteLength,this.length-=this.bufs[0].byteLength,this.bufs.shift();else{this.bufs[0]=this.bufs[0].subarray(t),this.length-=t;break}}}slice(t,e){let{bufs:r,length:n}=this._subList(t,e);return q(r,n)}subarray(t,e){let{bufs:r,length:n}=this._subList(t,e);return r.length===1?r[0]:q(r,n)}sublist(t,e){let{bufs:r,length:n}=this._subList(t,e),i=new s;return i.length=n,i.bufs=[...r],i}_subList(t,e){if(t=t??0,e=e??this.length,t<0&&(t=this.length+t),e<0&&(e=this.length+e),t<0||e>this.length)throw new RangeError("index is out of bounds");if(t===e)return{bufs:[],length:0};if(t===0&&e===this.length)return{bufs:this.bufs,length:this.length};let r=[],n=0;for(let i=0;i<this.bufs.length;i++){let a=this.bufs[i],h=n,l=h+a.byteLength;if(n=l,t>=l)continue;let m=t>=h&&t<l,p=e>h&&e<=l;if(m&&p){if(t===h&&e===l){r.push(a);break}let d=t-h;r.push(a.subarray(d,d+(e-t)));break}if(m){if(t===0){r.push(a);continue}r.push(a.subarray(t-h));continue}if(p){if(e===l){r.push(a);break}r.push(a.subarray(0,e-h));break}r.push(a)}return{bufs:r,length:e-t}}indexOf(t,e=0){if(!k(t)&&!(t instanceof Uint8Array))throw new TypeError('The "value" argument must be a Uint8ArrayList or Uint8Array');let r=t instanceof Uint8Array?t:t.subarray();if(e=Number(e??0),isNaN(e)&&(e=0),e<0&&(e=this.length+e),e<0&&(e=0),t.length===0)return e>this.length?this.length:e;let n=r.byteLength;if(n===0)throw new TypeError("search must be at least 1 byte long");let i=256,a=new Int32Array(i);for(let d=0;d<i;d++)a[d]=-1;for(let d=0;d<n;d++)a[r[d]]=d;let h=a,l=this.byteLength-r.byteLength,m=r.byteLength-1,p;for(let d=e;d<=l;d+=p){p=0;for(let b=m;b>=0;b--){let N=this.get(d+b);if(r[b]!==N){p=Math.max(1,b-h[N]);break}}if(p===0)return d}return-1}getInt8(t){let e=this.subarray(t,t+1);return new DataView(e.buffer,e.byteOffset,e.byteLength).getInt8(0)}setInt8(t,e){let r=L(1);new DataView(r.buffer,r.byteOffset,r.byteLength).setInt8(0,e),this.write(r,t)}getInt16(t,e){let r=this.subarray(t,t+2);return new DataView(r.buffer,r.byteOffset,r.byteLength).getInt16(0,e)}setInt16(t,e,r){let n=E(2);new DataView(n.buffer,n.byteOffset,n.byteLength).setInt16(0,e,r),this.write(n,t)}getInt32(t,e){let r=this.subarray(t,t+4);return new DataView(r.buffer,r.byteOffset,r.byteLength).getInt32(0,e)}setInt32(t,e,r){let n=E(4);new DataView(n.buffer,n.byteOffset,n.byteLength).setInt32(0,e,r),this.write(n,t)}getBigInt64(t,e){let r=this.subarray(t,t+8);return new DataView(r.buffer,r.byteOffset,r.byteLength).getBigInt64(0,e)}setBigInt64(t,e,r){let n=E(8);new DataView(n.buffer,n.byteOffset,n.byteLength).setBigInt64(0,e,r),this.write(n,t)}getUint8(t){let e=this.subarray(t,t+1);return new DataView(e.buffer,e.byteOffset,e.byteLength).getUint8(0)}setUint8(t,e){let r=L(1);new DataView(r.buffer,r.byteOffset,r.byteLength).setUint8(0,e),this.write(r,t)}getUint16(t,e){let r=this.subarray(t,t+2);return new DataView(r.buffer,r.byteOffset,r.byteLength).getUint16(0,e)}setUint16(t,e,r){let n=E(2);new DataView(n.buffer,n.byteOffset,n.byteLength).setUint16(0,e,r),this.write(n,t)}getUint32(t,e){let r=this.subarray(t,t+4);return new DataView(r.buffer,r.byteOffset,r.byteLength).getUint32(0,e)}setUint32(t,e,r){let n=E(4);new DataView(n.buffer,n.byteOffset,n.byteLength).setUint32(0,e,r),this.write(n,t)}getBigUint64(t,e){let r=this.subarray(t,t+8);return new DataView(r.buffer,r.byteOffset,r.byteLength).getBigUint64(0,e)}setBigUint64(t,e,r){let n=E(8);new DataView(n.buffer,n.byteOffset,n.byteLength).setBigUint64(0,e,r),this.write(n,t)}getFloat32(t,e){let r=this.subarray(t,t+4);return new DataView(r.buffer,r.byteOffset,r.byteLength).getFloat32(0,e)}setFloat32(t,e,r){let n=E(4);new DataView(n.buffer,n.byteOffset,n.byteLength).setFloat32(0,e,r),this.write(n,t)}getFloat64(t,e){let r=this.subarray(t,t+8);return new DataView(r.buffer,r.byteOffset,r.byteLength).getFloat64(0,e)}setFloat64(t,e,r){let n=E(8);new DataView(n.buffer,n.byteOffset,n.byteLength).setFloat64(0,e,r),this.write(n,t)}equals(t){if(t==null||!(t instanceof s)||t.bufs.length!==this.bufs.length)return!1;for(let e=0;e<this.bufs.length;e++)if(!it(this.bufs[e],t.bufs[e]))return!1;return!0}static fromUint8Arrays(t,e){let r=new s;return r.bufs=t,e==null&&(e=t.reduce((n,i)=>n+i.byteLength,0)),r.length=e,r}};var v="ERR_INVALID_FRAME",K="ERR_UNREQUESTED_PING",$="ERR_NOT_MATCHING_PING",Q="ERR_STREAM_ALREADY_EXISTS",j="ERR_DECODE_INVALID_VERSION",J="ERR_BOTH_CLIENTS",Z="ERR_RECV_WINDOW_EXCEEDED",lt=new Set([v,K,$,Q,j,J,Z]),R="ERR_INVALID_CONFIG",P="ERR_MUXER_LOCAL_CLOSED",tt="ERR_MUXER_REMOTE_CLOSED";var ht="ERR_STREAM_ABORT",ut="ERROR_MAX_OUTBOUND_STREAMS_EXCEEDED",ct="ERR_DECODE_IN_PROGRESS",C=256*1024,ft=16*1024*1024;var dt={enableKeepAlive:!0,keepAliveInterval:3e4,maxInboundStreams:1e3,maxOutboundStreams:1e3,initialStreamWindowSize:C,maxStreamWindowSize:ft,maxMessageSize:64*1024};function mt(s){if(s.keepAliveInterval<=0)throw new o("keep-alive interval must be positive",R);if(s.maxInboundStreams<0)throw new o("max inbound streams must be larger or equal 0",R);if(s.maxOutboundStreams<0)throw new o("max outbound streams must be larger or equal 0",R);if(s.initialStreamWindowSize<C)throw new o("InitialStreamWindowSize must be larger or equal 256 kB",R);if(s.maxStreamWindowSize<s.initialStreamWindowSize)throw new o("MaxStreamWindowSize must be larger than the InitialStreamWindowSize",R);if(s.maxStreamWindowSize>2**32-1)throw new o("MaxStreamWindowSize must be less than equal MAX_UINT32",R);if(s.maxMessageSize<1024)throw new o("MaxMessageSize must be greater than a kilobyte",R)}var f;(function(s){s[s.Data=0]="Data",s[s.WindowUpdate=1]="WindowUpdate",s[s.Ping=2]="Ping",s[s.GoAway=3]="GoAway"})(f||(f={}));var c;(function(s){s[s.SYN=1]="SYN",s[s.ACK=2]="ACK",s[s.FIN=4]="FIN",s[s.RST=8]="RST"})(c||(c={}));var Ve=Object.values(c).filter(s=>typeof s!="string"),gt=0,g;(function(s){s[s.NormalTermination=0]="NormalTermination",s[s.ProtocolError=1]="ProtocolError",s[s.InternalError=2]="InternalError"})(g||(g={}));var _=12;var wt=2**24;function Nt(s){if(s[0]!==gt)throw new o("Invalid frame version",j);return{type:s[1],flag:(s[2]<<8)+s[3],streamID:s[4]*wt+(s[5]<<16)+(s[6]<<8)+s[7],length:s[8]*wt+(s[9]<<16)+(s[10]<<8)+s[11]}}var V=class{source;buffer;frameInProgress;constructor(t){this.source=Ot(t),this.buffer=new S,this.frameInProgress=!1}async*emitFrames(){for await(let t of this.source)for(this.buffer.append(t);;){let e=this.readHeader();if(e===void 0)break;let{type:r,length:n}=e;r===f.Data?(this.frameInProgress=!0,yield{header:e,data:await this.readBytes(n)}):yield{header:e}}}readHeader(){if(this.frameInProgress)throw new o("decoding frame already in progress",ct);if(this.buffer.length<_)return;let t=Nt(this.buffer.subarray(0,_));return this.buffer.consume(_),t}async readBytes(t){if(this.buffer.length<t){for await(let r of this.source)if(this.buffer.append(r),this.buffer.length>=t)break}let e=this.buffer.sublist(0,t);return this.buffer.consume(t),this.frameInProgress=!1,e}};function Ot(s){if(s[Symbol.iterator]!==void 0){let t=s[Symbol.iterator]();return t.return=void 0,{[Symbol.iterator](){return t}}}else if(s[Symbol.asyncIterator]!==void 0){let t=s[Symbol.asyncIterator]();return t.return=void 0,{[Symbol.asyncIterator](){return t}}}else throw new Error("a source must be either an iterable or an async iterable")}function et(s){let t=new Uint8Array(_);return t[1]=s.type,t[2]=s.flag>>>8,t[3]=s.flag,t[4]=s.streamID>>>24,t[5]=s.streamID>>>16,t[6]=s.streamID>>>8,t[7]=s.streamID,t[8]=s.length>>>24,t[9]=s.length>>>16,t[10]=s.length>>>8,t[11]=s.length,t}var F=class extends Error{type;code;constructor(t,e,r){super(t??"The operation was aborted"),this.type="aborted",this.name=r??"AbortError",this.code=e??"ABORT_ERR"}};async function T(s,t,e){if(t==null)return s;if(t.aborted)return Promise.reject(new F(e?.errorMessage,e?.errorCode,e?.errorName));let r,n=new F(e?.errorMessage,e?.errorCode,e?.errorName);try{return await Promise.race([s,new Promise((i,a)=>{r=()=>{a(n)},t.addEventListener("abort",r)})])}finally{r!=null&&t.removeEventListener("abort",r)}}function pt(s){return s==null?!1:typeof s.then=="function"&&typeof s.catch=="function"&&typeof s.finally=="function"}function bt(s,t){let e=U(s).return?.();pt(e)&&e.catch(r=>{t.error("could not cause iterator to return",r)})}var Ut="ERR_STREAM_RESET",Wt="ERR_SINK_INVALID_STATE",Mt=5e3;function rt(s){return s==null?!1:typeof s.then=="function"&&typeof s.catch=="function"&&typeof s.finally=="function"}var G=class{id;direction;timeline;protocol;metadata;source;status;readStatus;writeStatus;log;sinkController;sinkEnd;closed;endErr;streamSource;onEnd;onCloseRead;onCloseWrite;onReset;onAbort;sendCloseWriteTimeout;sendingData;constructor(t){this.sinkController=new AbortController,this.sinkEnd=y(),this.closed=y(),this.log=t.log,this.status="open",this.readStatus="ready",this.writeStatus="ready",this.id=t.id,this.metadata=t.metadata??{},this.direction=t.direction,this.timeline={open:Date.now()},this.sendCloseWriteTimeout=t.sendCloseWriteTimeout??Mt,this.onEnd=t.onEnd,this.onCloseRead=t?.onCloseRead,this.onCloseWrite=t?.onCloseWrite,this.onReset=t?.onReset,this.onAbort=t?.onAbort,this.source=this.streamSource=M({onEnd:e=>{e!=null?this.log.trace("source ended with error",e):this.log.trace("source ended"),this.onSourceEnd(e)}}),this.sink=this.sink.bind(this)}async sink(t){if(this.writeStatus!=="ready")throw new o(`writable end state is "${this.writeStatus}" not "ready"`,Wt);try{this.writeStatus="writing";let e={signal:this.sinkController.signal};if(this.direction==="outbound"){let n=this.sendNewStream(e);rt(n)&&await n}let r=()=>{bt(t,this.log)};try{this.sinkController.signal.addEventListener("abort",r),this.log.trace("sink reading from source");for await(let n of t){n=n instanceof Uint8Array?new S(n):n;let i=this.sendData(n,e);rt(i)&&(this.sendingData=y(),await i,this.sendingData.resolve(),this.sendingData=void 0)}}finally{this.sinkController.signal.removeEventListener("abort",r)}this.log.trace('sink finished reading from source, write status is "%s"',this.writeStatus),this.writeStatus==="writing"&&(this.writeStatus="closing",this.log.trace("send close write to remote"),await this.sendCloseWrite({signal:AbortSignal.timeout(this.sendCloseWriteTimeout)}),this.writeStatus="closed"),this.onSinkEnd()}catch(e){throw this.log.trace("sink ended with error, calling abort with error",e),this.abort(e),e}finally{this.log.trace("resolve sink end"),this.sinkEnd.resolve()}}onSourceEnd(t){this.timeline.closeRead==null&&(this.timeline.closeRead=Date.now(),this.readStatus="closed",t!=null&&this.endErr==null&&(this.endErr=t),this.onCloseRead?.(),this.timeline.closeWrite!=null?(this.log.trace("source and sink ended"),this.timeline.close=Date.now(),this.status!=="aborted"&&this.status!=="reset"&&(this.status="closed"),this.onEnd!=null&&this.onEnd(this.endErr),this.closed.resolve()):this.log.trace("source ended, waiting for sink to end"))}onSinkEnd(t){this.timeline.closeWrite==null&&(this.timeline.closeWrite=Date.now(),this.writeStatus="closed",t!=null&&this.endErr==null&&(this.endErr=t),this.onCloseWrite?.(),this.timeline.closeRead!=null?(this.log.trace("sink and source ended"),this.timeline.close=Date.now(),this.status!=="aborted"&&this.status!=="reset"&&(this.status="closed"),this.onEnd!=null&&this.onEnd(this.endErr),this.closed.resolve()):this.log.trace("sink ended, waiting for source to end"))}async close(t){this.log.trace("closing gracefully"),this.status="closing",await T(Promise.all([this.closeWrite(t),this.closeRead(t),this.closed.promise]),t?.signal),this.status="closed",this.log.trace("closed gracefully")}async closeRead(t={}){if(this.readStatus==="closing"||this.readStatus==="closed")return;this.log.trace('closing readable end of stream with starting read status "%s"',this.readStatus);let e=this.readStatus;this.readStatus="closing",this.status!=="reset"&&this.status!=="aborted"&&this.timeline.closeRead==null&&(this.log.trace("send close read to remote"),await this.sendCloseRead(t)),e==="ready"&&(this.log.trace("ending internal source queue with %d queued bytes",this.streamSource.readableLength),this.streamSource.end()),this.log.trace("closed readable end of stream")}async closeWrite(t={}){this.writeStatus==="closing"||this.writeStatus==="closed"||(this.log.trace('closing writable end of stream with starting write status "%s"',this.writeStatus),this.writeStatus==="ready"&&(this.log.trace("sink was never sunk, sink an empty array"),await T(this.sink([]),t.signal)),this.writeStatus==="writing"&&(this.sendingData!=null&&await T(this.sendingData.promise,t.signal),this.log.trace("aborting source passed to .sink"),this.sinkController.abort(),await T(this.sinkEnd.promise,t.signal)),this.writeStatus="closed",this.log.trace("closed writable end of stream"))}abort(t){if(this.status==="closed"||this.status==="aborted"||this.status==="reset")return;this.log("abort with error",t),this.log("try to send reset to remote");let e=this.sendReset();rt(e)&&e.catch(r=>{this.log.error("error sending reset message",r)}),this.status="aborted",this.timeline.abort=Date.now(),this._closeSinkAndSource(t),this.onAbort?.(t)}reset(){if(this.status==="closed"||this.status==="aborted"||this.status==="reset")return;let t=new o("stream reset",Ut);this.status="reset",this.timeline.reset=Date.now(),this._closeSinkAndSource(t),this.onReset?.()}_closeSinkAndSource(t){this._closeSink(t),this._closeSource(t)}_closeSink(t){this.writeStatus==="writing"&&(this.log.trace("end sink source"),this.sinkController.abort()),this.onSinkEnd(t)}_closeSource(t){this.readStatus!=="closing"&&this.readStatus!=="closed"&&(this.log.trace("ending source with %d bytes to be read by consumer",this.streamSource.readableLength),this.readStatus="closing",this.streamSource.end(t))}remoteCloseWrite(){if(this.readStatus==="closing"||this.readStatus==="closed"){this.log("received remote close write but local source is already closed");return}this.log.trace("remote close write"),this._closeSource()}remoteCloseRead(){if(this.writeStatus==="closing"||this.writeStatus==="closed"){this.log("received remote close read but local sink is already closed");return}this.log.trace("remote close read"),this._closeSink()}destroy(){if(this.status==="closed"||this.status==="aborted"||this.status==="reset"){this.log("received destroy but we are already closed");return}this.log.trace("stream destroyed"),this._closeSinkAndSource()}sourcePush(t){this.streamSource.push(t)}sourceReadableLength(){return this.streamSource.readableLength}};function kt(s){let[t,e]=s[Symbol.asyncIterator]!=null?[s[Symbol.asyncIterator](),Symbol.asyncIterator]:[s[Symbol.iterator](),Symbol.iterator],r=[];return{peek:()=>t.next(),push:n=>{r.push(n)},next:()=>r.length>0?{done:!1,value:r.shift()}:t.next(),[e](){return this}}}var yt=kt;function Pt(s){return s[Symbol.asyncIterator]!=null}function Et(s){return s?.then!=null}function Vt(s,t){let e=0;if(Pt(s))return async function*(){for await(let l of s){let m=t(l,e++);Et(m)&&await m,yield l}}();let r=yt(s),{value:n,done:i}=r.next();if(i===!0)return function*(){}();if(typeof t(n,e++)?.then=="function")return async function*(){yield n;for await(let l of r){let m=t(l,e++);Et(m)&&await m,yield l}}();let h=t;return function*(){yield n;for(let l of r)h(l,e++),yield l}()}var St=Vt;var w;(function(s){s[s.Init=0]="Init",s[s.SYNSent=1]="SYNSent",s[s.SYNReceived=2]="SYNReceived",s[s.Established=3]="Established",s[s.Finished=4]="Finished"})(w||(w={}));var B=class extends G{name;state;config;_id;sendWindowCapacity;sendWindowCapacityUpdate;recvWindow;recvWindowCapacity;epochStart;getRTT;sendFrame;constructor(t){super({...t,onEnd:e=>{this.state=w.Finished,t.onEnd?.(e)}}),this.config=t.config,this._id=parseInt(t.id,10),this.name=t.name,this.state=t.state,this.sendWindowCapacity=C,this.recvWindow=this.config.initialStreamWindowSize,this.recvWindowCapacity=this.recvWindow,this.epochStart=Date.now(),this.getRTT=t.getRTT,this.sendFrame=t.sendFrame,this.source=St(this.source,()=>{this.sendWindowUpdate()})}async sendNewStream(){}async sendData(t,e={}){for(t=t.sublist();t.byteLength!==0;){if(this.sendWindowCapacity===0&&(this.log?.trace("wait for send window capacity, status %s",this.status),await this.waitForSendWindowCapacity(e),this.status==="closed"||this.status==="aborted"||this.status==="reset")){this.log?.trace("%s while waiting for send window capacity",this.status);return}let r=Math.min(this.sendWindowCapacity,this.config.maxMessageSize-_,t.length),n=this.getSendFlags();this.sendFrame({type:f.Data,flag:n,streamID:this._id,length:r},t.sublist(0,r)),this.sendWindowCapacity-=r,t.consume(r)}}async sendReset(){this.sendFrame({type:f.WindowUpdate,flag:c.RST,streamID:this._id,length:0})}async sendCloseWrite(){let t=this.getSendFlags()|c.FIN;this.sendFrame({type:f.WindowUpdate,flag:t,streamID:this._id,length:0})}async sendCloseRead(){}async waitForSendWindowCapacity(t={}){if(this.sendWindowCapacity>0)return;let e,r,n=()=>{this.status==="open"||this.status==="closing"?r(new o("stream aborted",ht)):e()};t.signal?.addEventListener("abort",n);try{await new Promise((i,a)=>{this.sendWindowCapacityUpdate=()=>{i()},r=a,e=i})}finally{t.signal?.removeEventListener("abort",n)}}handleWindowUpdate(t){this.log?.trace("stream received window update id=%s",this._id),this.processFlags(t.flag);let e=this.sendWindowCapacity;this.sendWindowCapacity+=t.length,e===0&&t.length>0&&this.sendWindowCapacityUpdate?.()}async handleData(t,e){if(this.log?.trace("stream received data id=%s",this._id),this.processFlags(t.flag),this.recvWindowCapacity<t.length)throw new o("receive window exceeded",Z,{available:this.recvWindowCapacity,recv:t.length});this.recvWindowCapacity-=t.length,this.sourcePush(e)}processFlags(t){(t&c.ACK)===c.ACK&&this.state===w.SYNSent&&(this.state=w.Established),(t&c.FIN)===c.FIN&&this.remoteCloseWrite(),(t&c.RST)===c.RST&&this.reset()}getSendFlags(){switch(this.state){case w.Init:return this.state=w.SYNSent,c.SYN;case w.SYNReceived:return this.state=w.Established,c.ACK;default:return 0}}sendWindowUpdate(){let t=this.getSendFlags(),e=Date.now(),r=this.getRTT();if(t===0&&r>-1&&e-this.epochStart<r*4&&(this.recvWindow=Math.min(this.recvWindow*2,this.config.maxStreamWindowSize)),this.recvWindowCapacity>=this.recvWindow&&t===0)return;let n=this.recvWindow-this.recvWindowCapacity;this.recvWindowCapacity=this.recvWindow,this.epochStart=e,this.sendFrame({type:f.WindowUpdate,flag:t,streamID:this._id,length:n})}};var Rt="/yamux/1.0.0",Ft=500,X=class{protocol=Rt;_components;_init;constructor(t,e={}){this._components=t,this._init=e}[Symbol.toStringTag]="@chainsafe/libp2p-yamux";[nt]=["@libp2p/stream-multiplexing"];createStreamMuxer(t){return new st(this._components,{...this._init,...t})}},st=class{protocol=Rt;source;sink;config;log;logger;closeController;nextStreamID;_streams;nextPingID;activePing;rtt;client;localGoAway;remoteGoAway;numInboundStreams;numOutboundStreams;onIncomingStream;onStreamEnd;constructor(t,e){this.client=e.direction==="outbound",this.config={...dt,...e},this.logger=t.logger,this.log=this.logger.forComponent("libp2p:yamux"),mt(this.config),this.closeController=new AbortController,Y(1/0,this.closeController.signal),this.onIncomingStream=e.onIncomingStream,this.onStreamEnd=e.onStreamEnd,this._streams=new Map,this.source=M({onEnd:()=>{this.log?.trace("muxer source ended"),this._streams.forEach(r=>{r.destroy()})}}),this.sink=async r=>{let n=()=>{let h=U(r);if(h.return!=null){let l=h.return();Gt(l)&&l.catch(m=>{this.log?.("could not cause sink source to return",m)})}},i,a;try{let h=new V(r);try{this.closeController.signal.addEventListener("abort",n);for await(let l of h.emitFrames())await this.handleFrame(l.header,l.data)}finally{this.closeController.signal.removeEventListener("abort",n)}i=g.NormalTermination}catch(h){let l=h.code;lt.has(l)?(this.log?.error("protocol error in sink",h),i=g.ProtocolError):(this.log?.error("internal error in sink",h),i=g.InternalError),a=h}this.log?.trace("muxer sink ended"),a!=null?this.abort(a,i):await this.close({reason:i})},this.numInboundStreams=0,this.numOutboundStreams=0,this.nextStreamID=this.client?1:2,this.nextPingID=0,this.rtt=-1,this.log?.trace("muxer created"),this.config.enableKeepAlive&&this.keepAliveLoop().catch(r=>this.log?.error("keepalive error: %s",r)),this.ping().catch(r=>this.log?.error("ping error: %s",r))}get streams(){return Array.from(this._streams.values())}newStream(t){if(this.remoteGoAway!==void 0)throw new o("muxer closed remotely",tt);if(this.localGoAway!==void 0)throw new o("muxer closed locally",P);let e=this.nextStreamID;if(this.nextStreamID+=2,this.numOutboundStreams>=this.config.maxOutboundStreams)throw new o("max outbound streams exceeded",ut);this.log?.trace("new outgoing stream id=%s",e);let r=this._newStream(e,t,w.Init,"outbound");return this._streams.set(e,r),this.numOutboundStreams++,r.sendWindowUpdate(),r}async ping(){if(this.remoteGoAway!==void 0)throw new o("muxer closed remotely",tt);if(this.localGoAway!==void 0)throw new o("muxer closed locally",P);if(this.activePing===void 0){let t=()=>{};this.activePing={id:this.nextPingID++,promise:new Promise((n,i)=>{let a=()=>{i(new o("muxer closed locally",P))};this.closeController.signal.addEventListener("abort",a,{once:!0}),t=()=>{this.closeController.signal.removeEventListener("abort",a),n()}}),resolve:t};let e=Date.now();this.sendPing(this.activePing.id);try{await this.activePing.promise}finally{delete this.activePing}let r=Date.now();this.rtt=r-e}else await this.activePing.promise;return this.rtt}getRTT(){return this.rtt}async close(t={}){if(this.closeController.signal.aborted)return;let e=t?.reason??g.NormalTermination;if(this.log?.trace("muxer close reason=%s",e),t.signal==null){let r=AbortSignal.timeout(Ft);Y(1/0,r),t={...t,signal:r}}try{await Promise.all([...this._streams.values()].map(async r=>r.close(t))),this.sendGoAway(e),this._closeMuxer()}catch(r){this.abort(r)}}abort(t,e){if(!this.closeController.signal.aborted){e=e??g.InternalError,this.log?.error("muxer abort reason=%s error=%s",e,t);for(let r of this._streams.values())r.abort(t);this.sendGoAway(e),this._closeMuxer()}}isClosed(){return this.closeController.signal.aborted}_closeMuxer(){this.closeController.abort(),this.source.end()}_newStream(t,e,r,n){if(this._streams.get(t)!=null)throw new o("Stream already exists",Q,{id:t});let i=new B({id:t.toString(),name:e,state:r,direction:n,sendFrame:this.sendFrame.bind(this),onEnd:()=>{this.closeStream(t),this.onStreamEnd?.(i)},log:this.logger.forComponent(`libp2p:yamux:${n}:${t}`),config:this.config,getRTT:this.getRTT.bind(this)});return i}closeStream(t){this.client===(t%2===0)?this.numInboundStreams--:this.numOutboundStreams--,this._streams.delete(t)}async keepAliveLoop(){let t=new Promise((e,r)=>{this.closeController.signal.addEventListener("abort",r,{once:!0})});for(this.log?.trace("muxer keepalive enabled interval=%s",this.config.keepAliveInterval);;){let e;try{await Promise.race([t,new Promise(r=>{e=setTimeout(r,this.config.keepAliveInterval)})]),this.ping().catch(r=>this.log?.error("ping error: %s",r))}catch{clearInterval(e);return}}}async handleFrame(t,e){let{streamID:r,type:n,length:i}=t;if(this.log?.trace("received frame %o",t),r===0)switch(n){case f.Ping:{this.handlePing(t);return}case f.GoAway:{this.handleGoAway(i);return}default:throw new o("Invalid frame type",v,{header:t})}else switch(t.type){case f.Data:case f.WindowUpdate:{await this.handleStreamMessage(t,e);return}default:throw new o("Invalid frame type",v,{header:t})}}handlePing(t){if(t.flag===c.SYN)this.log?.trace("received ping request pingId=%s",t.length),this.sendPing(t.length,c.ACK);else if(t.flag===c.ACK)this.log?.trace("received ping response pingId=%s",t.length),this.handlePingResponse(t.length);else throw new o("Invalid frame flag",v,{header:t})}handlePingResponse(t){if(this.activePing===void 0)throw new o("ping not requested",K);if(this.activePing.id!==t)throw new o("ping doesn't match our id",$);this.activePing.resolve()}handleGoAway(t){this.log?.trace("received GoAway reason=%s",g[t]??"unknown"),this.remoteGoAway=t;for(let e of this._streams.values())e.reset();this._closeMuxer()}async handleStreamMessage(t,e){let{streamID:r,flag:n,type:i}=t;(n&c.SYN)===c.SYN&&this.incomingStream(r);let a=this._streams.get(r);if(a===void 0){i===f.Data?this.log?.("discarding data for stream id=%s",r):this.log?.("frame for missing stream id=%s",r);return}switch(i){case f.WindowUpdate:{a.handleWindowUpdate(t);return}case f.Data:{if(e===void 0)throw new Error("unreachable");await a.handleData(t,e);return}default:throw new Error("unreachable")}}incomingStream(t){if(this.client!==(t%2===0))throw new o("both endpoints are clients",J);if(this._streams.has(t))return;if(this.log?.trace("new incoming stream id=%s",t),this.localGoAway!==void 0){this.sendFrame({type:f.WindowUpdate,flag:c.RST,streamID:t,length:0});return}if(this.numInboundStreams>=this.config.maxInboundStreams){this.log?.("maxIncomingStreams exceeded, forcing stream reset"),this.sendFrame({type:f.WindowUpdate,flag:c.RST,streamID:t,length:0});return}let e=this._newStream(t,void 0,w.SYNReceived,"inbound");this.numInboundStreams++,this._streams.set(t,e),this.onIncomingStream?.(e)}sendFrame(t,e){if(this.log?.trace("sending frame %o",t),t.type===f.Data){if(e===void 0)throw new o("invalid frame",v);this.source.push(new S(et(t),e))}else this.source.push(et(t))}sendPing(t,e=c.SYN){e===c.SYN?this.log?.trace("sending ping request pingId=%s",t):this.log?.trace("sending ping response pingId=%s",t),this.sendFrame({type:f.Ping,flag:e,streamID:0,length:t})}sendGoAway(t=g.NormalTermination){this.log?.("sending GoAway reason=%s",g[t]),this.localGoAway=t,this.sendFrame({type:f.GoAway,flag:0,streamID:0,length:t})}};function Gt(s){return s!=null&&typeof s.then=="function"}function Bt(s={}){return t=>new X(t,s)}return Ct(Xt);})();
return ChainsafeLibp2PYamux}));
