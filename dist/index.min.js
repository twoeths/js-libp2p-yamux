(function (root, factory) {(typeof module === 'object' && module.exports) ? module.exports = factory() : root.ChainsafeLibp2PYamux = factory()}(typeof self !== 'undefined' ? self : this, function () {
"use strict";var ChainsafeLibp2PYamux=(()=>{var z=Object.defineProperty;var It=Object.getOwnPropertyDescriptor;var At=Object.getOwnPropertyNames;var Dt=Object.prototype.hasOwnProperty;var xt=(r,t)=>{for(var e in t)z(r,e,{get:t[e],enumerable:!0})},vt=(r,t,e,s)=>{if(t&&typeof t=="object"||typeof t=="function")for(let n of At(t))!Dt.call(r,n)&&n!==e&&z(r,n,{get:()=>t[n],enumerable:!(s=It(t,n))||s.enumerable});return r};var Lt=r=>vt(z({},"__esModule",{value:!0}),r);var Bt={};xt(Bt,{GoAwayCode:()=>w,yamux:()=>Gt});var o=class extends Error{code;props;constructor(t,e,s){super(t),this.code=e,this.name=s?.name??"CodeError",this.props=s??{}}};var Y=(r,...t)=>{try{[...t]}catch{}};function U(r){if(r!=null){if(typeof r[Symbol.iterator]=="function")return r[Symbol.iterator]();if(typeof r[Symbol.asyncIterator]=="function")return r[Symbol.asyncIterator]();if(typeof r.next=="function")return r}throw new Error("argument is not an iterator or iterable")}function y(){let r={};return r.promise=new Promise((t,e)=>{r.resolve=t,r.reject=e}),r}var W=class{buffer;mask;top;btm;next;constructor(t){if(!(t>0)||t-1&t)throw new Error("Max size for a FixedFIFO should be a power of two");this.buffer=new Array(t),this.mask=t-1,this.top=0,this.btm=0,this.next=null}push(t){return this.buffer[this.top]!==void 0?!1:(this.buffer[this.top]=t,this.top=this.top+1&this.mask,!0)}shift(){let t=this.buffer[this.btm];if(t!==void 0)return this.buffer[this.btm]=void 0,this.btm=this.btm+1&this.mask,t}isEmpty(){return this.buffer[this.btm]===void 0}},x=class{size;hwm;head;tail;constructor(t={}){this.hwm=t.splitLimit??16,this.head=new W(this.hwm),this.tail=this.head,this.size=0}calculateSize(t){return t?.byteLength!=null?t.byteLength:1}push(t){if(t?.value!=null&&(this.size+=this.calculateSize(t.value)),!this.head.push(t)){let e=this.head;this.head=e.next=new W(2*this.head.buffer.length),this.head.push(t)}}shift(){let t=this.tail.shift();if(t===void 0&&this.tail.next!=null){let e=this.tail.next;this.tail.next=null,this.tail=e,t=this.tail.shift()}return t?.value!=null&&(this.size-=this.calculateSize(t.value)),t}isEmpty(){return this.head.isEmpty()}};var H=class extends Error{type;code;constructor(t,e){super(t??"The operation was aborted"),this.type="aborted",this.code=e??"ABORT_ERR"}};function M(r={}){return Ct(e=>{let s=e.shift();if(s==null)return{done:!0};if(s.error!=null)throw s.error;return{done:s.done===!0,value:s.value}},r)}function Ct(r,t){t=t??{};let e=t.onEnd,s=new x,n,i,a,h=y(),l=async()=>{try{return s.isEmpty()?a?{done:!0}:await new Promise((u,I)=>{i=O=>{i=null,s.push(O);try{u(r(s))}catch(D){I(D)}return n}}):r(s)}finally{s.isEmpty()&&queueMicrotask(()=>{h.resolve(),h=y()})}},m=u=>i!=null?i(u):(s.push(u),n),p=u=>(s=new x,i!=null?i({error:u}):(s.push({error:u}),n)),d=u=>{if(a)return n;if(t?.objectMode!==!0&&u?.byteLength==null)throw new Error("objectMode was not true but tried to push non-Uint8Array value");return m({done:!1,value:u})},b=u=>a?n:(a=!0,u!=null?p(u):m({done:!0})),N=()=>(s=new x,b(),{done:!0}),Rt=u=>(b(u),{done:!0});if(n={[Symbol.asyncIterator](){return this},next:l,return:N,throw:Rt,push:d,end:b,get readableLength(){return s.size},onEmpty:async u=>{let I=u?.signal;if(I?.throwIfAborted(),s.isEmpty())return;let O,D;I!=null&&(O=new Promise((Xt,_t)=>{D=()=>{_t(new H)},I.addEventListener("abort",D)}));try{await Promise.race([h.promise,O])}finally{D!=null&&I!=null&&I?.removeEventListener("abort",D)}}},e==null)return n;let A=n;return n={[Symbol.asyncIterator](){return this},next(){return A.next()},throw(u){return A.throw(u),e!=null&&(e(u),e=void 0),{done:!0}},return(){return A.return(),e!=null&&(e(),e=void 0),{done:!0}},push:d,end(u){return A.end(u),e!=null&&(e(u),e=void 0),n},get readableLength(){return A.readableLength},onEmpty:u=>A.onEmpty(u)},n}function E(r=0){return new Uint8Array(r)}function L(r=0){return new Uint8Array(r)}function q(r,t){t==null&&(t=r.reduce((n,i)=>n+i.length,0));let e=L(t),s=0;for(let n of r)e.set(n,s),s+=n.length;return e}function nt(r,t){if(r===t)return!0;if(r.byteLength!==t.byteLength)return!1;for(let e=0;e<r.byteLength;e++)if(r[e]!==t[e])return!1;return!0}var ot=Symbol.for("@achingbrain/uint8arraylist");function it(r,t){if(t==null||t<0)throw new RangeError("index is out of bounds");let e=0;for(let s of r){let n=e+s.byteLength;if(t<n)return{buf:s,index:t-e};e=n}throw new RangeError("index is out of bounds")}function k(r){return!!r?.[ot]}var S=class r{bufs;length;[ot]=!0;constructor(...t){this.bufs=[],this.length=0,t.length>0&&this.appendAll(t)}*[Symbol.iterator](){yield*this.bufs}get byteLength(){return this.length}append(...t){this.appendAll(t)}appendAll(t){let e=0;for(let s of t)if(s instanceof Uint8Array)e+=s.byteLength,this.bufs.push(s);else if(k(s))e+=s.byteLength,this.bufs.push(...s.bufs);else throw new Error("Could not append value, must be an Uint8Array or a Uint8ArrayList");this.length+=e}prepend(...t){this.prependAll(t)}prependAll(t){let e=0;for(let s of t.reverse())if(s instanceof Uint8Array)e+=s.byteLength,this.bufs.unshift(s);else if(k(s))e+=s.byteLength,this.bufs.unshift(...s.bufs);else throw new Error("Could not prepend value, must be an Uint8Array or a Uint8ArrayList");this.length+=e}get(t){let e=it(this.bufs,t);return e.buf[e.index]}set(t,e){let s=it(this.bufs,t);s.buf[s.index]=e}write(t,e=0){if(t instanceof Uint8Array)for(let s=0;s<t.length;s++)this.set(e+s,t[s]);else if(k(t))for(let s=0;s<t.length;s++)this.set(e+s,t.get(s));else throw new Error("Could not write value, must be an Uint8Array or a Uint8ArrayList")}consume(t){if(t=Math.trunc(t),!(Number.isNaN(t)||t<=0)){if(t===this.byteLength){this.bufs=[],this.length=0;return}for(;this.bufs.length>0;)if(t>=this.bufs[0].byteLength)t-=this.bufs[0].byteLength,this.length-=this.bufs[0].byteLength,this.bufs.shift();else{this.bufs[0]=this.bufs[0].subarray(t),this.length-=t;break}}}slice(t,e){let{bufs:s,length:n}=this._subList(t,e);return q(s,n)}subarray(t,e){let{bufs:s,length:n}=this._subList(t,e);return s.length===1?s[0]:q(s,n)}sublist(t,e){let{bufs:s,length:n}=this._subList(t,e),i=new r;return i.length=n,i.bufs=[...s],i}_subList(t,e){if(t=t??0,e=e??this.length,t<0&&(t=this.length+t),e<0&&(e=this.length+e),t<0||e>this.length)throw new RangeError("index is out of bounds");if(t===e)return{bufs:[],length:0};if(t===0&&e===this.length)return{bufs:this.bufs,length:this.length};let s=[],n=0;for(let i=0;i<this.bufs.length;i++){let a=this.bufs[i],h=n,l=h+a.byteLength;if(n=l,t>=l)continue;let m=t>=h&&t<l,p=e>h&&e<=l;if(m&&p){if(t===h&&e===l){s.push(a);break}let d=t-h;s.push(a.subarray(d,d+(e-t)));break}if(m){if(t===0){s.push(a);continue}s.push(a.subarray(t-h));continue}if(p){if(e===l){s.push(a);break}s.push(a.subarray(0,e-h));break}s.push(a)}return{bufs:s,length:e-t}}indexOf(t,e=0){if(!k(t)&&!(t instanceof Uint8Array))throw new TypeError('The "value" argument must be a Uint8ArrayList or Uint8Array');let s=t instanceof Uint8Array?t:t.subarray();if(e=Number(e??0),isNaN(e)&&(e=0),e<0&&(e=this.length+e),e<0&&(e=0),t.length===0)return e>this.length?this.length:e;let n=s.byteLength;if(n===0)throw new TypeError("search must be at least 1 byte long");let i=256,a=new Int32Array(i);for(let d=0;d<i;d++)a[d]=-1;for(let d=0;d<n;d++)a[s[d]]=d;let h=a,l=this.byteLength-s.byteLength,m=s.byteLength-1,p;for(let d=e;d<=l;d+=p){p=0;for(let b=m;b>=0;b--){let N=this.get(d+b);if(s[b]!==N){p=Math.max(1,b-h[N]);break}}if(p===0)return d}return-1}getInt8(t){let e=this.subarray(t,t+1);return new DataView(e.buffer,e.byteOffset,e.byteLength).getInt8(0)}setInt8(t,e){let s=L(1);new DataView(s.buffer,s.byteOffset,s.byteLength).setInt8(0,e),this.write(s,t)}getInt16(t,e){let s=this.subarray(t,t+2);return new DataView(s.buffer,s.byteOffset,s.byteLength).getInt16(0,e)}setInt16(t,e,s){let n=E(2);new DataView(n.buffer,n.byteOffset,n.byteLength).setInt16(0,e,s),this.write(n,t)}getInt32(t,e){let s=this.subarray(t,t+4);return new DataView(s.buffer,s.byteOffset,s.byteLength).getInt32(0,e)}setInt32(t,e,s){let n=E(4);new DataView(n.buffer,n.byteOffset,n.byteLength).setInt32(0,e,s),this.write(n,t)}getBigInt64(t,e){let s=this.subarray(t,t+8);return new DataView(s.buffer,s.byteOffset,s.byteLength).getBigInt64(0,e)}setBigInt64(t,e,s){let n=E(8);new DataView(n.buffer,n.byteOffset,n.byteLength).setBigInt64(0,e,s),this.write(n,t)}getUint8(t){let e=this.subarray(t,t+1);return new DataView(e.buffer,e.byteOffset,e.byteLength).getUint8(0)}setUint8(t,e){let s=L(1);new DataView(s.buffer,s.byteOffset,s.byteLength).setUint8(0,e),this.write(s,t)}getUint16(t,e){let s=this.subarray(t,t+2);return new DataView(s.buffer,s.byteOffset,s.byteLength).getUint16(0,e)}setUint16(t,e,s){let n=E(2);new DataView(n.buffer,n.byteOffset,n.byteLength).setUint16(0,e,s),this.write(n,t)}getUint32(t,e){let s=this.subarray(t,t+4);return new DataView(s.buffer,s.byteOffset,s.byteLength).getUint32(0,e)}setUint32(t,e,s){let n=E(4);new DataView(n.buffer,n.byteOffset,n.byteLength).setUint32(0,e,s),this.write(n,t)}getBigUint64(t,e){let s=this.subarray(t,t+8);return new DataView(s.buffer,s.byteOffset,s.byteLength).getBigUint64(0,e)}setBigUint64(t,e,s){let n=E(8);new DataView(n.buffer,n.byteOffset,n.byteLength).setBigUint64(0,e,s),this.write(n,t)}getFloat32(t,e){let s=this.subarray(t,t+4);return new DataView(s.buffer,s.byteOffset,s.byteLength).getFloat32(0,e)}setFloat32(t,e,s){let n=E(4);new DataView(n.buffer,n.byteOffset,n.byteLength).setFloat32(0,e,s),this.write(n,t)}getFloat64(t,e){let s=this.subarray(t,t+8);return new DataView(s.buffer,s.byteOffset,s.byteLength).getFloat64(0,e)}setFloat64(t,e,s){let n=E(8);new DataView(n.buffer,n.byteOffset,n.byteLength).setFloat64(0,e,s),this.write(n,t)}equals(t){if(t==null||!(t instanceof r)||t.bufs.length!==this.bufs.length)return!1;for(let e=0;e<this.bufs.length;e++)if(!nt(this.bufs[e],t.bufs[e]))return!1;return!0}static fromUint8Arrays(t,e){let s=new r;return s.bufs=t,e==null&&(e=t.reduce((n,i)=>n+i.byteLength,0)),s.length=e,s}};var v="ERR_INVALID_FRAME",K="ERR_UNREQUESTED_PING",$="ERR_NOT_MATCHING_PING",Q="ERR_STREAM_ALREADY_EXISTS",j="ERR_DECODE_INVALID_VERSION",J="ERR_BOTH_CLIENTS",Z="ERR_RECV_WINDOW_EXCEEDED",at=new Set([v,K,$,Q,j,J,Z]),R="ERR_INVALID_CONFIG",P="ERR_MUXER_LOCAL_CLOSED",tt="ERR_MUXER_REMOTE_CLOSED";var lt="ERR_STREAM_ABORT",ht="ERROR_MAX_OUTBOUND_STREAMS_EXCEEDED",ut="ERR_DECODE_IN_PROGRESS",C=256*1024,ct=16*1024*1024;var ft={enableKeepAlive:!0,keepAliveInterval:3e4,maxInboundStreams:1e3,maxOutboundStreams:1e3,initialStreamWindowSize:C,maxStreamWindowSize:ct,maxMessageSize:64*1024};function dt(r){if(r.keepAliveInterval<=0)throw new o("keep-alive interval must be positive",R);if(r.maxInboundStreams<0)throw new o("max inbound streams must be larger or equal 0",R);if(r.maxOutboundStreams<0)throw new o("max outbound streams must be larger or equal 0",R);if(r.initialStreamWindowSize<C)throw new o("InitialStreamWindowSize must be larger or equal 256 kB",R);if(r.maxStreamWindowSize<r.initialStreamWindowSize)throw new o("MaxStreamWindowSize must be larger than the InitialStreamWindowSize",R);if(r.maxStreamWindowSize>2**32-1)throw new o("MaxStreamWindowSize must be less than equal MAX_UINT32",R);if(r.maxMessageSize<1024)throw new o("MaxMessageSize must be greater than a kilobyte",R)}var f;(function(r){r[r.Data=0]="Data",r[r.WindowUpdate=1]="WindowUpdate",r[r.Ping=2]="Ping",r[r.GoAway=3]="GoAway"})(f||(f={}));var c;(function(r){r[r.SYN=1]="SYN",r[r.ACK=2]="ACK",r[r.FIN=4]="FIN",r[r.RST=8]="RST"})(c||(c={}));var me=Object.values(c).filter(r=>typeof r!="string"),mt=0,w;(function(r){r[r.NormalTermination=0]="NormalTermination",r[r.ProtocolError=1]="ProtocolError",r[r.InternalError=2]="InternalError"})(w||(w={}));var _=12;var wt=2**24;function Tt(r){if(r[0]!==mt)throw new o("Invalid frame version",j);return{type:r[1],flag:(r[2]<<8)+r[3],streamID:r[4]*wt+(r[5]<<16)+(r[6]<<8)+r[7],length:r[8]*wt+(r[9]<<16)+(r[10]<<8)+r[11]}}var V=class{source;buffer;frameInProgress;constructor(t){this.source=Nt(t),this.buffer=new S,this.frameInProgress=!1}async*emitFrames(){for await(let t of this.source)for(this.buffer.append(t);;){let e=this.readHeader();if(e===void 0)break;let{type:s,length:n}=e;s===f.Data?(this.frameInProgress=!0,yield{header:e,readData:this.readBytes.bind(this,n)}):yield{header:e}}}readHeader(){if(this.frameInProgress)throw new o("decoding frame already in progress",ut);if(this.buffer.length<_)return;let t=Tt(this.buffer.subarray(0,_));return this.buffer.consume(_),t}async readBytes(t){if(this.buffer.length<t){for await(let s of this.source)if(this.buffer.append(s),this.buffer.length>=t)break}let e=this.buffer.sublist(0,t);return this.buffer.consume(t),this.frameInProgress=!1,e}};function Nt(r){if(r[Symbol.iterator]!==void 0){let t=r[Symbol.iterator]();return t.return=void 0,{[Symbol.iterator](){return t}}}else if(r[Symbol.asyncIterator]!==void 0){let t=r[Symbol.asyncIterator]();return t.return=void 0,{[Symbol.asyncIterator](){return t}}}else throw new Error("a source must be either an iterable or an async iterable")}function et(r){let t=new Uint8Array(_);return t[1]=r.type,t[2]=r.flag>>>8,t[3]=r.flag,t[4]=r.streamID>>>24,t[5]=r.streamID>>>16,t[6]=r.streamID>>>8,t[7]=r.streamID,t[8]=r.length>>>24,t[9]=r.length>>>16,t[10]=r.length>>>8,t[11]=r.length,t}var F=class extends Error{type;code;constructor(t,e,s){super(t??"The operation was aborted"),this.type="aborted",this.name=s??"AbortError",this.code=e??"ABORT_ERR"}};async function T(r,t,e){if(t==null)return r;if(t.aborted)return Promise.reject(new F(e?.errorMessage,e?.errorCode,e?.errorName));let s,n=new F(e?.errorMessage,e?.errorCode,e?.errorName);try{return await Promise.race([r,new Promise((i,a)=>{s=()=>{a(n)},t.addEventListener("abort",s)})])}finally{s!=null&&t.removeEventListener("abort",s)}}function gt(r){return r==null?!1:typeof r.then=="function"&&typeof r.catch=="function"&&typeof r.finally=="function"}function pt(r,t){let e=U(r).return?.();gt(e)&&e.catch(s=>{t.error("could not cause iterator to return",s)})}var Ot="ERR_STREAM_RESET",Ut="ERR_SINK_INVALID_STATE",Wt=5e3;function st(r){return r==null?!1:typeof r.then=="function"&&typeof r.catch=="function"&&typeof r.finally=="function"}var G=class{id;direction;timeline;protocol;metadata;source;status;readStatus;writeStatus;log;sinkController;sinkEnd;closed;endErr;streamSource;onEnd;onCloseRead;onCloseWrite;onReset;onAbort;sendCloseWriteTimeout;sendingData;constructor(t){this.sinkController=new AbortController,this.sinkEnd=y(),this.closed=y(),this.log=t.log,this.status="open",this.readStatus="ready",this.writeStatus="ready",this.id=t.id,this.metadata=t.metadata??{},this.direction=t.direction,this.timeline={open:Date.now()},this.sendCloseWriteTimeout=t.sendCloseWriteTimeout??Wt,this.onEnd=t.onEnd,this.onCloseRead=t?.onCloseRead,this.onCloseWrite=t?.onCloseWrite,this.onReset=t?.onReset,this.onAbort=t?.onAbort,this.source=this.streamSource=M({onEnd:e=>{e!=null?this.log.trace("source ended with error",e):this.log.trace("source ended"),this.onSourceEnd(e)}}),this.sink=this.sink.bind(this)}async sink(t){if(this.writeStatus!=="ready")throw new o(`writable end state is "${this.writeStatus}" not "ready"`,Ut);try{this.writeStatus="writing";let e={signal:this.sinkController.signal};if(this.direction==="outbound"){let n=this.sendNewStream(e);st(n)&&await n}let s=()=>{pt(t,this.log)};try{this.sinkController.signal.addEventListener("abort",s),this.log.trace("sink reading from source");for await(let n of t){n=n instanceof Uint8Array?new S(n):n;let i=this.sendData(n,e);st(i)&&(this.sendingData=y(),await i,this.sendingData.resolve(),this.sendingData=void 0)}}finally{this.sinkController.signal.removeEventListener("abort",s)}this.log.trace('sink finished reading from source, write status is "%s"',this.writeStatus),this.writeStatus==="writing"&&(this.writeStatus="closing",this.log.trace("send close write to remote"),await this.sendCloseWrite({signal:AbortSignal.timeout(this.sendCloseWriteTimeout)}),this.writeStatus="closed"),this.onSinkEnd()}catch(e){throw this.log.trace("sink ended with error, calling abort with error",e),this.abort(e),e}finally{this.log.trace("resolve sink end"),this.sinkEnd.resolve()}}onSourceEnd(t){this.timeline.closeRead==null&&(this.timeline.closeRead=Date.now(),this.readStatus="closed",t!=null&&this.endErr==null&&(this.endErr=t),this.onCloseRead?.(),this.timeline.closeWrite!=null?(this.log.trace("source and sink ended"),this.timeline.close=Date.now(),this.status!=="aborted"&&this.status!=="reset"&&(this.status="closed"),this.onEnd!=null&&this.onEnd(this.endErr),this.closed.resolve()):this.log.trace("source ended, waiting for sink to end"))}onSinkEnd(t){this.timeline.closeWrite==null&&(this.timeline.closeWrite=Date.now(),this.writeStatus="closed",t!=null&&this.endErr==null&&(this.endErr=t),this.onCloseWrite?.(),this.timeline.closeRead!=null?(this.log.trace("sink and source ended"),this.timeline.close=Date.now(),this.status!=="aborted"&&this.status!=="reset"&&(this.status="closed"),this.onEnd!=null&&this.onEnd(this.endErr),this.closed.resolve()):this.log.trace("sink ended, waiting for source to end"))}async close(t){this.log.trace("closing gracefully"),this.status="closing",await T(Promise.all([this.closeWrite(t),this.closeRead(t),this.closed.promise]),t?.signal),this.status="closed",this.log.trace("closed gracefully")}async closeRead(t={}){if(this.readStatus==="closing"||this.readStatus==="closed")return;this.log.trace('closing readable end of stream with starting read status "%s"',this.readStatus);let e=this.readStatus;this.readStatus="closing",this.status!=="reset"&&this.status!=="aborted"&&this.timeline.closeRead==null&&(this.log.trace("send close read to remote"),await this.sendCloseRead(t)),e==="ready"&&(this.log.trace("ending internal source queue with %d queued bytes",this.streamSource.readableLength),this.streamSource.end()),this.log.trace("closed readable end of stream")}async closeWrite(t={}){this.writeStatus==="closing"||this.writeStatus==="closed"||(this.log.trace('closing writable end of stream with starting write status "%s"',this.writeStatus),this.writeStatus==="ready"&&(this.log.trace("sink was never sunk, sink an empty array"),await T(this.sink([]),t.signal)),this.writeStatus==="writing"&&(this.sendingData!=null&&await T(this.sendingData.promise,t.signal),this.log.trace("aborting source passed to .sink"),this.sinkController.abort(),await T(this.sinkEnd.promise,t.signal)),this.writeStatus="closed",this.log.trace("closed writable end of stream"))}abort(t){if(this.status==="closed"||this.status==="aborted"||this.status==="reset")return;this.log("abort with error",t),this.log("try to send reset to remote");let e=this.sendReset();st(e)&&e.catch(s=>{this.log.error("error sending reset message",s)}),this.status="aborted",this.timeline.abort=Date.now(),this._closeSinkAndSource(t),this.onAbort?.(t)}reset(){if(this.status==="closed"||this.status==="aborted"||this.status==="reset")return;let t=new o("stream reset",Ot);this.status="reset",this.timeline.reset=Date.now(),this._closeSinkAndSource(t),this.onReset?.()}_closeSinkAndSource(t){this._closeSink(t),this._closeSource(t)}_closeSink(t){this.writeStatus==="writing"&&(this.log.trace("end sink source"),this.sinkController.abort()),this.onSinkEnd(t)}_closeSource(t){this.readStatus!=="closing"&&this.readStatus!=="closed"&&(this.log.trace("ending source with %d bytes to be read by consumer",this.streamSource.readableLength),this.readStatus="closing",this.streamSource.end(t))}remoteCloseWrite(){if(this.readStatus==="closing"||this.readStatus==="closed"){this.log("received remote close write but local source is already closed");return}this.log.trace("remote close write"),this._closeSource()}remoteCloseRead(){if(this.writeStatus==="closing"||this.writeStatus==="closed"){this.log("received remote close read but local sink is already closed");return}this.log.trace("remote close read"),this._closeSink()}destroy(){if(this.status==="closed"||this.status==="aborted"||this.status==="reset"){this.log("received destroy but we are already closed");return}this.log.trace("stream destroyed"),this._closeSinkAndSource()}sourcePush(t){this.streamSource.push(t)}sourceReadableLength(){return this.streamSource.readableLength}};function Mt(r){let[t,e]=r[Symbol.asyncIterator]!=null?[r[Symbol.asyncIterator](),Symbol.asyncIterator]:[r[Symbol.iterator](),Symbol.iterator],s=[];return{peek:()=>t.next(),push:n=>{s.push(n)},next:()=>s.length>0?{done:!1,value:s.shift()}:t.next(),[e](){return this}}}var bt=Mt;function kt(r){return r[Symbol.asyncIterator]!=null}function yt(r){return r?.then!=null}function Pt(r,t){let e=0;if(kt(r))return async function*(){for await(let l of r){let m=t(l,e++);yt(m)&&await m,yield l}}();let s=bt(r),{value:n,done:i}=s.next();if(i===!0)return function*(){}();if(typeof t(n,e++)?.then=="function")return async function*(){yield n;for await(let l of s){let m=t(l,e++);yt(m)&&await m,yield l}}();let h=t;return function*(){yield n;for(let l of s)h(l,e++),yield l}()}var Et=Pt;var g;(function(r){r[r.Init=0]="Init",r[r.SYNSent=1]="SYNSent",r[r.SYNReceived=2]="SYNReceived",r[r.Established=3]="Established",r[r.Finished=4]="Finished"})(g||(g={}));var B=class extends G{name;state;config;_id;sendWindowCapacity;sendWindowCapacityUpdate;recvWindow;recvWindowCapacity;epochStart;getRTT;sendFrame;constructor(t){super({...t,onEnd:e=>{this.state=g.Finished,t.onEnd?.(e)}}),this.config=t.config,this._id=parseInt(t.id,10),this.name=t.name,this.state=t.state,this.sendWindowCapacity=C,this.recvWindow=this.config.initialStreamWindowSize,this.recvWindowCapacity=this.recvWindow,this.epochStart=Date.now(),this.getRTT=t.getRTT,this.sendFrame=t.sendFrame,this.source=Et(this.source,()=>{this.sendWindowUpdate()})}async sendNewStream(){}async sendData(t,e={}){for(t=t.sublist();t.byteLength!==0;){if(this.sendWindowCapacity===0&&(this.log?.trace("wait for send window capacity, status %s",this.status),await this.waitForSendWindowCapacity(e),this.status==="closed"||this.status==="aborted"||this.status==="reset")){this.log?.trace("%s while waiting for send window capacity",this.status);return}let s=Math.min(this.sendWindowCapacity,this.config.maxMessageSize-_,t.length),n=this.getSendFlags();this.sendFrame({type:f.Data,flag:n,streamID:this._id,length:s},t.sublist(0,s)),this.sendWindowCapacity-=s,t.consume(s)}}async sendReset(){this.sendFrame({type:f.WindowUpdate,flag:c.RST,streamID:this._id,length:0})}async sendCloseWrite(){let t=this.getSendFlags()|c.FIN;this.sendFrame({type:f.WindowUpdate,flag:t,streamID:this._id,length:0})}async sendCloseRead(){}async waitForSendWindowCapacity(t={}){if(this.sendWindowCapacity>0)return;let e,s,n=()=>{this.status==="open"||this.status==="closing"?s(new o("stream aborted",lt)):e()};t.signal?.addEventListener("abort",n);try{await new Promise((i,a)=>{this.sendWindowCapacityUpdate=()=>{i()},s=a,e=i})}finally{t.signal?.removeEventListener("abort",n)}}handleWindowUpdate(t){this.log?.trace("stream received window update id=%s",this._id),this.processFlags(t.flag);let e=this.sendWindowCapacity;this.sendWindowCapacity+=t.length,e===0&&t.length>0&&this.sendWindowCapacityUpdate?.()}async handleData(t,e){if(this.log?.trace("stream received data id=%s",this._id),this.processFlags(t.flag),this.recvWindowCapacity<t.length)throw new o("receive window exceeded",Z,{available:this.recvWindowCapacity,recv:t.length});let s=await e();this.recvWindowCapacity-=t.length,this.sourcePush(s)}processFlags(t){(t&c.ACK)===c.ACK&&this.state===g.SYNSent&&(this.state=g.Established),(t&c.FIN)===c.FIN&&this.remoteCloseWrite(),(t&c.RST)===c.RST&&this.reset()}getSendFlags(){switch(this.state){case g.Init:return this.state=g.SYNSent,c.SYN;case g.SYNReceived:return this.state=g.Established,c.ACK;default:return 0}}sendWindowUpdate(){let t=this.getSendFlags(),e=Date.now(),s=this.getRTT();if(t===0&&s>-1&&e-this.epochStart<s*4&&(this.recvWindow=Math.min(this.recvWindow*2,this.config.maxStreamWindowSize)),this.recvWindowCapacity>=this.recvWindow&&t===0)return;let n=this.recvWindow-this.recvWindowCapacity;this.recvWindowCapacity=this.recvWindow,this.epochStart=e,this.sendFrame({type:f.WindowUpdate,flag:t,streamID:this._id,length:n})}};var St="/yamux/1.0.0",Vt=500,X=class{protocol=St;_components;_init;constructor(t,e={}){this._components=t,this._init=e}createStreamMuxer(t){return new rt(this._components,{...this._init,...t})}},rt=class{protocol=St;source;sink;config;log;logger;closeController;nextStreamID;_streams;nextPingID;activePing;rtt;client;localGoAway;remoteGoAway;numInboundStreams;numOutboundStreams;onIncomingStream;onStreamEnd;constructor(t,e){this.client=e.direction==="outbound",this.config={...ft,...e},this.logger=t.logger,this.log=this.logger.forComponent("libp2p:yamux"),dt(this.config),this.closeController=new AbortController,Y(1/0,this.closeController.signal),this.onIncomingStream=e.onIncomingStream,this.onStreamEnd=e.onStreamEnd,this._streams=new Map,this.source=M({onEnd:()=>{this.log?.trace("muxer source ended"),this._streams.forEach(s=>{s.destroy()})}}),this.sink=async s=>{let n=()=>{let h=U(s);if(h.return!=null){let l=h.return();Ft(l)&&l.catch(m=>{this.log?.("could not cause sink source to return",m)})}},i,a;try{let h=new V(s);try{this.closeController.signal.addEventListener("abort",n);for await(let l of h.emitFrames())await this.handleFrame(l.header,l.readData)}finally{this.closeController.signal.removeEventListener("abort",n)}i=w.NormalTermination}catch(h){let l=h.code;at.has(l)?(this.log?.error("protocol error in sink",h),i=w.ProtocolError):(this.log?.error("internal error in sink",h),i=w.InternalError),a=h}this.log?.trace("muxer sink ended"),a!=null?this.abort(a,i):await this.close({reason:i})},this.numInboundStreams=0,this.numOutboundStreams=0,this.nextStreamID=this.client?1:2,this.nextPingID=0,this.rtt=-1,this.log?.trace("muxer created"),this.config.enableKeepAlive&&this.keepAliveLoop().catch(s=>this.log?.error("keepalive error: %s",s)),this.ping().catch(s=>this.log?.error("ping error: %s",s))}get streams(){return Array.from(this._streams.values())}newStream(t){if(this.remoteGoAway!==void 0)throw new o("muxer closed remotely",tt);if(this.localGoAway!==void 0)throw new o("muxer closed locally",P);let e=this.nextStreamID;if(this.nextStreamID+=2,this.numOutboundStreams>=this.config.maxOutboundStreams)throw new o("max outbound streams exceeded",ht);this.log?.trace("new outgoing stream id=%s",e);let s=this._newStream(e,t,g.Init,"outbound");return this._streams.set(e,s),this.numOutboundStreams++,s.sendWindowUpdate(),s}async ping(){if(this.remoteGoAway!==void 0)throw new o("muxer closed remotely",tt);if(this.localGoAway!==void 0)throw new o("muxer closed locally",P);if(this.activePing===void 0){let t=()=>{};this.activePing={id:this.nextPingID++,promise:new Promise((n,i)=>{let a=()=>{i(new o("muxer closed locally",P))};this.closeController.signal.addEventListener("abort",a,{once:!0}),t=()=>{this.closeController.signal.removeEventListener("abort",a),n()}}),resolve:t};let e=Date.now();this.sendPing(this.activePing.id);try{await this.activePing.promise}finally{delete this.activePing}let s=Date.now();this.rtt=s-e}else await this.activePing.promise;return this.rtt}getRTT(){return this.rtt}async close(t={}){if(this.closeController.signal.aborted)return;let e=t?.reason??w.NormalTermination;if(this.log?.trace("muxer close reason=%s",e),t.signal==null){let s=AbortSignal.timeout(Vt);Y(1/0,s),t={...t,signal:s}}try{await Promise.all([...this._streams.values()].map(async s=>s.close(t))),this.sendGoAway(e),this._closeMuxer()}catch(s){this.abort(s)}}abort(t,e){if(!this.closeController.signal.aborted){e=e??w.InternalError,this.log?.error("muxer abort reason=%s error=%s",e,t);for(let s of this._streams.values())s.abort(t);this.sendGoAway(e),this._closeMuxer()}}isClosed(){return this.closeController.signal.aborted}_closeMuxer(){this.closeController.abort(),this.source.end()}_newStream(t,e,s,n){if(this._streams.get(t)!=null)throw new o("Stream already exists",Q,{id:t});let i=new B({id:t.toString(),name:e,state:s,direction:n,sendFrame:this.sendFrame.bind(this),onEnd:()=>{this.closeStream(t),this.onStreamEnd?.(i)},log:this.logger.forComponent(`libp2p:yamux:${n}:${t}`),config:this.config,getRTT:this.getRTT.bind(this)});return i}closeStream(t){this.client===(t%2===0)?this.numInboundStreams--:this.numOutboundStreams--,this._streams.delete(t)}async keepAliveLoop(){let t=new Promise((e,s)=>{this.closeController.signal.addEventListener("abort",s,{once:!0})});for(this.log?.trace("muxer keepalive enabled interval=%s",this.config.keepAliveInterval);;){let e;try{await Promise.race([t,new Promise(s=>{e=setTimeout(s,this.config.keepAliveInterval)})]),this.ping().catch(s=>this.log?.error("ping error: %s",s))}catch{clearInterval(e);return}}}async handleFrame(t,e){let{streamID:s,type:n,length:i}=t;if(this.log?.trace("received frame %o",t),s===0)switch(n){case f.Ping:{this.handlePing(t);return}case f.GoAway:{this.handleGoAway(i);return}default:throw new o("Invalid frame type",v,{header:t})}else switch(t.type){case f.Data:case f.WindowUpdate:{await this.handleStreamMessage(t,e);return}default:throw new o("Invalid frame type",v,{header:t})}}handlePing(t){if(t.flag===c.SYN)this.log?.trace("received ping request pingId=%s",t.length),this.sendPing(t.length,c.ACK);else if(t.flag===c.ACK)this.log?.trace("received ping response pingId=%s",t.length),this.handlePingResponse(t.length);else throw new o("Invalid frame flag",v,{header:t})}handlePingResponse(t){if(this.activePing===void 0)throw new o("ping not requested",K);if(this.activePing.id!==t)throw new o("ping doesn't match our id",$);this.activePing.resolve()}handleGoAway(t){this.log?.trace("received GoAway reason=%s",w[t]??"unknown"),this.remoteGoAway=t;for(let e of this._streams.values())e.reset();this._closeMuxer()}async handleStreamMessage(t,e){let{streamID:s,flag:n,type:i}=t;(n&c.SYN)===c.SYN&&this.incomingStream(s);let a=this._streams.get(s);if(a===void 0){if(i===f.Data){if(this.log?.("discarding data for stream id=%s",s),e===void 0)throw new Error("unreachable");await e()}else this.log?.("frame for missing stream id=%s",s);return}switch(i){case f.WindowUpdate:{a.handleWindowUpdate(t);return}case f.Data:{if(e===void 0)throw new Error("unreachable");await a.handleData(t,e);return}default:throw new Error("unreachable")}}incomingStream(t){if(this.client!==(t%2===0))throw new o("both endpoints are clients",J);if(this._streams.has(t))return;if(this.log?.trace("new incoming stream id=%s",t),this.localGoAway!==void 0){this.sendFrame({type:f.WindowUpdate,flag:c.RST,streamID:t,length:0});return}if(this.numInboundStreams>=this.config.maxInboundStreams){this.log?.("maxIncomingStreams exceeded, forcing stream reset"),this.sendFrame({type:f.WindowUpdate,flag:c.RST,streamID:t,length:0});return}let e=this._newStream(t,void 0,g.SYNReceived,"inbound");this.numInboundStreams++,this._streams.set(t,e),this.onIncomingStream?.(e)}sendFrame(t,e){if(this.log?.trace("sending frame %o",t),t.type===f.Data){if(e===void 0)throw new o("invalid frame",v);this.source.push(new S(et(t),e))}else this.source.push(et(t))}sendPing(t,e=c.SYN){e===c.SYN?this.log?.trace("sending ping request pingId=%s",t):this.log?.trace("sending ping response pingId=%s",t),this.sendFrame({type:f.Ping,flag:e,streamID:0,length:t})}sendGoAway(t=w.NormalTermination){this.log?.("sending GoAway reason=%s",w[t]),this.localGoAway=t,this.sendFrame({type:f.GoAway,flag:0,streamID:0,length:t})}};function Ft(r){return r!=null&&typeof r.then=="function"}function Gt(r={}){return t=>new X(t,r)}return Lt(Bt);})();
return ChainsafeLibp2PYamux}));
